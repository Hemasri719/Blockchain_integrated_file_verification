// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title FileIntegrity
 * @dev A smart contract to store and verify the integrity of file hashes and IPFS CIDs on the Ethereum blockchain.
 * Designed for a Blood Bank File Integrity System to ensure records are tamper-proof.
 */
contract FileIntegrity {
    // Structure to hold details for each file record
    struct FileRecord {
        string fileName;    // Original name of the file
        string fileHash;    // SHA256 hash of the file content
        string ipfsCid;     // IPFS Content Identifier (CID) for the file
        address uploader;   // Ethereum address of the entity that uploaded the file
        uint256 timestamp;  // Unix timestamp of when the file was uploaded
        string metadata;    // Additional metadata (e.g., Donor ID, Blood Type)
    }

    // Mapping from a unique file ID (string) to its corresponding FileRecord
    // This allows quick retrieval of a record by its unique identifier.
    mapping(string => FileRecord) public fileRecords;

    // An array to store all unique file IDs. This is used to iterate through all stored records.
    string[] public fileIds;

    // Event emitted when a new file record is successfully uploaded to the blockchain.
    event FileUploaded(
        string fileId,
        string fileName,
        string fileHash,
        string ipfsCid,
        address uploader,
        uint256 timestamp,
        string metadata
    );

    // Event emitted when a file's integrity is verified.
    event FileVerified(
        string fileId,
        string providedFileHash,
        bool isValid
    );

    /**
     * @dev Uploads a new file record to the blockchain.
     * @param _fileId A unique identifier for the file (e.g., a UUID generated by the backend).
     * @param _fileName The original name of the uploaded file.
     * @param _fileHash The SHA256 hash of the file's content.
     * @param _ipfsCid The IPFS Content Identifier where the file is stored.
     * @param _metadata Additional metadata associated with the file (e.g., Donor ID).
     */
    function uploadFile(
        string memory _fileId,
        string memory _fileName,
        string memory _fileHash,
        string memory _ipfsCid,
        string memory _metadata
    ) public {
        // Ensure that a file with this _fileId does not already exist to prevent overwrites.
        require(bytes(fileRecords[_fileId].fileHash).length == 0, "File with this ID already exists.");

        // Store the new file record in the mapping.
        fileRecords[_fileId] = FileRecord({
            fileName: _fileName,
            fileHash: _fileHash,
            ipfsCid: _ipfsCid,
            uploader: msg.sender,     // The address that called this function
            timestamp: block.timestamp, // The current block timestamp
            metadata: _metadata
        });

        // Add the unique _fileId to the list of all file IDs.
        fileIds.push(_fileId);

        // Emit an event to log the successful upload, which can be monitored off-chain.
        emit FileUploaded(_fileId, _fileName, _fileHash, _ipfsCid, msg.sender, block.timestamp, _metadata);
    }

    /**
     * @dev Verifies the integrity of a file by comparing a provided hash with the stored hash.
     * This function does not change state, so it's a `view` function.
     * @param _fileId The unique identifier of the file to verify.
     * @param _providedFileHash The SHA256 hash of the file being checked.
     * @return A boolean indicating if the provided hash matches the stored hash.
     */
    function verifyFile(string memory _fileId, string memory _providedFileHash) public view returns (bool) {
        // Retrieve the stored file hash for the given _fileId.
        string memory storedHash = fileRecords[_fileId].fileHash;

        // Compare the provided hash with the stored hash.
        // Using keccak256(abi.encodePacked(...)) ensures a proper byte-by-byte comparison for strings.
        bool isValid = keccak256(abi.encodePacked(storedHash)) == keccak256(abi.encodePacked(_providedFileHash));

        // Emit an event for verification (useful for logging/monitoring off-chain).
        emit FileVerified(_fileId, _providedFileHash, isValid);

        return isValid;
    }

    /**
     * @dev Retrieves all details of a specific file record.
     * This is a `view` function as it only reads state.
     * @param _fileId The unique identifier of the file.
     * @return All fields of the FileRecord struct: fileName, fileHash, ipfsCid, uploader, timestamp, metadata.
     */
    function getFileDetails(string memory _fileId) public view returns (
        string memory fileName,
        string memory fileHash,
        string memory ipfsCid,
        address uploader,
        uint256 timestamp,
        string memory metadata
    ) {
        FileRecord storage record = fileRecords[_fileId];
        return (record.fileName, record.fileHash, record.ipfsCid, record.uploader, record.timestamp, record.metadata);
    }

    /**
     * @dev Retrieves an array of all unique file IDs stored in the contract.
     * This is a `view` function.
     * @return An array of strings, where each string is a file ID.
     */
    function getAllFileIds() public view returns (string[] memory) {
        return fileIds;
    }
}
