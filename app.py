import os
import hashlib
import json
import uuid
from flask import Flask, request, jsonify
from flask_cors import CORS
from web3 import Web3
# Ensure you have 'pycryptodome' installed for any future encryption needs,
# though current implementation focuses on hashing and IPFS.
# from Crypto.Cipher import AES
# from Crypto.Util.Padding import pad, unpad

# For IPFS interaction. Make sure your IPFS daemon is running!
# pip install ipfshttpclient
try:
    from ipfshttpclient import connect as ipfs_connect
except ImportError:
    print("WARNING: 'ipfshttpclient' not found. IPFS functionality will be disabled.")
    print("Please install it using: pip install ipfshttpclient")
    ipfs_connect = None

app = Flask(__name__)
# Enable Cross-Origin Resource Sharing (CORS) for the frontend to communicate with this backend.
CORS(app)

# --- Configuration ---
# Ethereum node URL. Default to Hardhat's local node.
# You can set this as an environment variable or hardcode it.
WEB3_PROVIDER_URL = os.getenv('WEB3_PROVIDER_URL', 'http://127.0.0.1:8545')

# Path to your compiled smart contract's ABI JSON file.
# This file is generated by Hardhat (e.g., after `npx hardhat compile`).
CONTRACT_ABI_PATH = './artifacts/contracts/FileIntegrity.sol/FileIntegrity.json'

# --- IMPORTANT: REPLACE THIS WITH YOUR DEPLOYED CONTRACT ADDRESS ---
# After deploying your FileIntegrity.sol contract, update this variable
# with the actual address of the deployed contract.
CONTRACT_ADDRESS = os.getenv('CONTRACT_ADDRESS', '0x5FbDB2315678afecb367f032d93F642f64180aa3') # Example address, replace!

# IPFS API URL. Default to local IPFS daemon.
IPFS_API_URL = os.getenv('IPFS_API_URL', '/ip4/127.0.0.1/tcp/5001') # Default for local IPFS daemon

# --- Initialize Web3 ---
w3 = Web3(Web3.HTTPProvider(WEB3_PROVIDER_URL))

# Check if connection to Ethereum node is successful
if not w3.is_connected():
    print(f"ERROR: Failed to connect to Ethereum node at {WEB3_PROVIDER_URL}")
    print("Please ensure your Ethereum node (e.g., Hardhat) is running.")
    exit() # Exit if we can't connect to the blockchain
else:
    print(f"Connected to Ethereum node at {WEB3_PROVIDER_URL}")

# Load Contract ABI (Application Binary Interface)
try:
    with open(CONTRACT_ABI_PATH, 'r') as f:
        contract_data = json.load(f)
        CONTRACT_ABI = contract_data['abi']
except FileNotFoundError:
    print(f"ERROR: Contract ABI not found at {CONTRACT_ABI_PATH}")
    print("Please compile your smart contract first (e.g., `npx hardhat compile`).")
    exit() # Exit if ABI is missing

# Initialize the smart contract instance
contract = w3.eth.contract(address=CONTRACT_ADDRESS, abi=CONTRACT_ABI)
print(f"Smart contract loaded from address: {CONTRACT_ADDRESS}")

# --- Initialize IPFS client ---
ipfs_client = None
if ipfs_connect:
    try:
        ipfs_client = ipfs_connect(IPFS_API_URL)
        ipfs_id = ipfs_client.id() # Test connection
        print(f"Connected to IPFS daemon: {ipfs_id['ID']}")
    except Exception as e:
        print(f"WARNING: Could not connect to IPFS daemon at {IPFS_API_URL}. IPFS functionality will be disabled.")
        print(f"Error details: {e}")
else:
    print("IPFS client library not installed, IPFS functionality disabled.")


# --- Helper Functions ---
def hash_file(file_content: bytes) -> str:
    """
    Calculates the SHA256 hash of the given file content.
    :param file_content: The byte content of the file.
    :return: The hexadecimal string representation of the SHA256 hash.
    """
    return hashlib.sha256(file_content).hexdigest()

# Note: Original JS code had encryption/decryption.
# For a full Python equivalent, you'd integrate a library like PyCryptodome.
# For simplicity and focus on blockchain/IPFS integrity,
# these are omitted from this core backend example unless explicitly requested.

# --- API Endpoints ---

@app.route('/upload', methods=['POST'])
def upload_file():
    """
    Handles file upload requests.
    - Reads the file and metadata from the request.
    - Hashes the file content.
    - Adds the file to IPFS and retrieves its CID.
    - Generates a unique file ID.
    - Stores the file details (ID, name, hash, CID, uploader, timestamp, metadata)
      on the Ethereum blockchain via the FileIntegrity smart contract.
    """
    # Check if a file was sent in the request
    if 'file' not in request.files:
        return jsonify({'error': 'No file part in the request'}), 400

    file = request.files['file']
    metadata = request.form.get('metadata', '') # Get metadata from form data

    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400

    file_name = file.filename
    file_content = file.read() # Read file content as bytes
    file_hash = hash_file(file_content)
    ipfs_cid = "" # Initialize IPFS CID

    try:
        # --- IPFS Upload ---
        if ipfs_client:
            print(f"Attempting to add {file_name} to IPFS...")
            add_result = ipfs_client.add(file_content)
            ipfs_cid = add_result['Hash']
            print(f"File added to IPFS. CID: {ipfs_cid}")
        else:
            print("IPFS client not connected. Skipping IPFS upload.")
            return jsonify({'error': 'IPFS service is not available.'}), 500

        # --- Blockchain Interaction ---
        # Get the first unlocked account from the connected Ethereum node.
        # In a real application, you'd use a more secure way to manage accounts/private keys.
        accounts = w3.eth.accounts
        if not accounts:
            return jsonify({'error': 'No unlocked Ethereum accounts found. Ensure Hardhat node is running and has unlocked accounts.'}), 500
        uploader_account = accounts[0] # Use the first available account for transactions

        # Generate a unique file ID using UUID (Universally Unique Identifier)
        file_id = str(uuid.uuid4())

        print(f"Attempting to upload file details to blockchain for file ID: {file_id}")
        print(f"  File Name: {file_name}")
        print(f"  File Hash: {file_hash}")
        print(f"  IPFS CID: {ipfs_cid}")
        print(f"  Metadata: {metadata}")
        print(f"  Uploader: {uploader_account}")

        # Build the transaction to call the smart contract's `uploadFile` function
        # Ensure the smart contract's `uploadFile` function signature matches these parameters.
        transaction = contract.functions.uploadFile(
            file_id,
            file_name,
            file_hash,
            ipfs_cid,
            metadata
        ).build_transaction({
            'from': uploader_account,
            'gasPrice': w3.eth.gas_price, # Automatically determine gas price
            'gas': 3000000 # Set a reasonable gas limit (adjust if needed)
        })

        # Sign and send the transaction
        # If using Hardhat, accounts are typically unlocked for local testing.
        # For production, you'd need to sign with a private key.
        tx_hash = w3.eth.send_transaction(transaction)
        print(f"Transaction sent. Hash: {tx_hash.hex()}")

        # Wait for the transaction to be mined and get the receipt
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
        print(f"Transaction confirmed in block: {tx_receipt.blockNumber}")

        return jsonify({
            'success': True,
            'fileId': file_id,
            'fileHash': file_hash,
            'ipfsCid': ipfs_cid,
            'message': 'File uploaded and record stored on blockchain',
            'transactionHash': tx_hash.hex()
        }), 200

    except Exception as e:
        print(f"Upload error: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/verify', methods=['POST'])
def verify_file():
    """
    Handles file integrity verification requests.
    - Reads the provided file content from the request.
    - Hashes the provided file content.
    - Fetches all file records from the blockchain.
    - Compares the provided file's hash with hashes stored on the blockchain
      to find a match.
    """
    if 'file' not in request.files:
        return jsonify({'error': 'No file part in the request'}), 400

    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400

    file_content = file.read()
    provided_file_hash = hash_file(file_content)

    try:
        print(f"Attempting to verify file with provided hash: {provided_file_hash}")
        # Fetch all file IDs from the smart contract
        all_file_ids = contract.functions.getAllFileIds().call()
        found_record = None

        # Iterate through each file ID and retrieve its details from the blockchain
        for file_id in all_file_ids:
            # getFileDetails returns (fileName, fileHash, ipfsCid, uploader, timestamp, metadata)
            record = contract.functions.getFileDetails(file_id).call()
            stored_file_hash = record[1] # The second element is the fileHash

            # Compare the provided hash with the stored hash
            if stored_file_hash == provided_file_hash:
                # If a match is found, construct the record details for the frontend
                found_record = {
                    "fileName": record[0],
                    "fileHash": record[1],
                    "ipfsCid": record[2],
                    "uploader": record[3],
                    "timestamp": record[4],
                    "metadata": record[5]
                }
                # No need to call verifyFile on contract directly, as we're doing a manual lookup.
                # If the contract's verifyFile was needed for specific logic, it could be called here.
                break # Exit loop once a match is found

        if found_record:
            print(f"File verified successfully! Matching record found for hash: {provided_file_hash}")
            return jsonify({
                'isValid': True,
                'record': found_record,
                'message': 'File integrity verified successfully!'
            }), 200
        else:
            print(f"File not found or hash mismatch for provided hash: {provided_file_hash}")
            return jsonify({'isValid': False, 'message': 'File not found or hash mismatch.'}), 200

    except Exception as e:
        print(f"Verification error: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/records', methods=['GET'])
def get_records():
    """
    Retrieves all file records stored on the blockchain.
    - Fetches all file IDs.
    - For each ID, retrieves the full record details from the smart contract.
    - Returns a JSON array of all records.
    """
    try:
        print("Fetching all records from blockchain...")
        all_file_ids = contract.functions.getAllFileIds().call()
        records = []
        for file_id in all_file_ids:
            # getFileDetails returns (fileName, fileHash, ipfsCid, uploader, timestamp, metadata)
            record_data = contract.functions.getFileDetails(file_id).call()
            records.append({
                "fileId": file_id,
                "fileName": record_data[0],
                "fileHash": record_data[1],
                "ipfsCid": record_data[2],
                "uploader": record_data[3],
                "timestamp": record_data[4],
                "metadata": record_data[5]
            })
        print(f"Found {len(records)} records.")
        return jsonify(records), 200
    except Exception as e:
        print(f"Error fetching records: {e}")
        return jsonify({'error': str(e)}), 500

# --- Main Application Run ---
if __name__ == '__main__':
    # Create an 'uploads' directory if it doesn't exist.
    # While we are using IPFS, this directory might be useful for temporary storage
    # or if you decide to add local encryption/decryption features later.
    if not os.path.exists('uploads'):
        os.makedirs('uploads')
    print("Starting Flask application...")
    app.run(debug=True, port=5000) # Run in debug mode for development, on port 5000
